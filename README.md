# Fibonacci 성능 개선 보고서 (O(n) -> O(log n))

## 1. 목적
피보나치 수 F(n) mod 1,000,000,007 계산에서
- 선형 반복(O(n))과
- Fast Doubling(O(log n))
알고리즘의 성능을 비교하고, 대입 가능한 최적 해법을 정리한다.

## 2. 구현 요약
- `fib_linear(n)`: 반복문으로 F(0)~F(n) 계산 (O(n))
- `fib_fast(n)`: fast doubling으로 (F(n), F(n+1))를 재귀적으로 계산 (O(log n))
- 모듈 연산은 `mod_add/sub/mul`로 정규화하여 overflow/음수 처리 문제를 방지했다.

## 3. 벤치마크 방법
- `std::chrono::steady_clock` 기반 측정
- 각 알고리즘을 목표 누적 실행시간(약 200ms 이상)까지 반복 실행 후 평균 `ns/call` 산출
- 결과값은 XOR로 소비해(volatile) 컴파일러 최적화로 계산이 사라지는 것을 방지했다.

## 4. 결과
| N | linear (ns/call) | fast (ns/call) | speedup (linear/fast) |
|---:|-----------------:|---------------:|----------------------:|
| 1 | 1.43 | 3.91 | 0.37x |
| 10 | 3.99 | 18.38 | 0.22x |
| 100 | 58.11 | 37.28 | 1.56x |
| 1,000 | 660.00 | 59.61 | 11.07x |
| 10,000 | 6513.35 | 85.10 | 76.54x |
| 100,000 | 64811.33 | 102.88 | 629.88x |

## 5. 해석
- 작은 n(1, 10)에서는 `fib_fast`가 더 느렸다.
  - 재귀 호출/분기/곱셈 등 고정 오버헤드가 커서 손해가 발생한다.
- n이 커질수록 `fib_linear`는 선형으로 느려지는 반면, `fib_fast`는 증가폭이 매우 완만했다.
  - n=100부터는 fast doubling이 우세(약 1.56배)
  - n=100,000에서는 약 630배 성능 향상

## 6. 결론
- n이 충분히 큰 입력이 예상되는 경우 fast doubling(O(log n))이 사실상 최적 선택이다.
- 매우 작은 n 중심이라면 단순 반복(O(n))이 더 빠를 수 있다.
- 본 측정에서는 n=100,000 기준 평균 비용이 64,811 ns/call -> 102.88 ns/call로 감소(약 630배 개선).
